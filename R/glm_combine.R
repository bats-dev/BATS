#' @name bats.combine
#' @title Combines BATS outputs
#' @description Combines different evaluations of BATS::bats.glm considering the same trial design but different sets of seeds. This function is useful when the evaluation of Monte Carlo samples generated by different seeds was split in sets computed by different nodes/cpus. The output of this function is of class 'bats' meaning that the usual generic functions (print, summary, plot) can be used.
#' @param paths Vector indicating the paths to the rdata files containing the outputs of the function BATS::bats.glm considering the same trial design but different set of seeds. This requires the argument 'full' of the function BATS::bats.glm to be 'TRUE'. 
#' @export
bats.combine = function(paths){# paths
    ##
    ## load results 
    ##
    objlist = as.list(rep(NA,length(paths)))
    for(ow in 1:length(paths)){# ow=2
        loaded = load(paths[ow])
        if(length(loaded)==1){
            if(!inherits(get(loaded),"bats")){stop("loaded object not of class 'bats'")}
        }else{
            if(length(loaded)>1){
                class.obj = rep(NA,length(loaded))
                for(oww in 1:length(loaded)){
                    class.obj[oww] = class(get(loaded[oww]))=="bats"
                }
                loaded = loaded[class.obj][1]
            }
        }
        objlist[[ow]]  = get(loaded)
    }
    

    ##
    ## combine results
    ##
    out     = objlist[[1]]
    if(is.null(out$call$extended)|(out$call$extended<1)){stop("argument 'extended' of the loaded object is NULL or equal to 0")}
    n.look  = nrow(out$look)
    # seeds
    for(ow in 2:length(objlist)){
        out$par$seed = c(out$par$seed,objlist[[ow]]$par$seed)
    }
    if(any(table(out$par$seed)>1)){stop("duplicated seeds")}
    # H0 and H1 trials
    Hw      = c("H0","H1")[c(objlist[[1]]$par$H0,objlist[[1]]$par$H1)]
    for(hw in 1:length(Hw)){# hw=1
        n.obj   = length(objlist)
        id.target = objlist[[1]][[Hw[hw]]]$trial[[1]]$target
        estimate  = objlist[[1]][[Hw[hw]]]$estimate
        trial_r   = objlist[[1]][[Hw[hw]]]$trial
        for(ow in 2:n.obj){
            if(is.null(objlist[[ow]]$call$extended)|(objlist[[ow]]$call$extended<1)){
                    stop("argument 'extended' of the loaded object is NULL or equal to 0")
                }            
            estimate = abind::abind(estimate,objlist[[ow]][[Hw[hw]]]$estimate,along=3)
            trial_r  = c(trial_r,objlist[[ow]][[Hw[hw]]]$trial)
        }
        tar.p  = bats.res.tp(estimate,id.target)
        tar.g  = bats.res.tg(estimate,id.target)
        eff.p  = bats.res.ep(estimate,id.target,n.look)
        eff.g  = bats.res.eg(estimate,id.target,n.look)
        fut.p  = bats.res.fp(estimate,id.target,n.look)
        fut.g  = bats.res.fg(estimate,id.target,n.look)
        sample = bats.res.s1(trial_r,group=out$par$group$id,
                              type=c(apply(estimate[,"type",,drop=FALSE],2:3,paste0,collapse="")),
                              early=apply(estimate[,"look",,drop=TRUE]<n.look,2,all))
        scenario = bats.res.s2(sample,target=id.target$id)
        out[[Hw[hw]]] = list(estimate = estimate,
                        target   = list(par=tar.p,global=tar.g),
                        efficacy = list(par=eff.p,global=eff.g),
                        futility = list(par=fut.p,global=fut.g),
                        sample=sample,scenario=scenario)
        if(!is.null(out$call$extended)){
            if(out$call$extended>0){
                out[[Hw[hw]]]$trial = trial_r
            }       
        }
    }
    out
}
